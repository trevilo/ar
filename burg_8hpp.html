<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Burg: burg.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Burg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">burg.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Burg's method and autoregressive model selection.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;algorithm&gt;</code><br/>
<code>#include &lt;cassert&gt;</code><br/>
<code>#include &lt;cmath&gt;</code><br/>
<code>#include &lt;functional&gt;</code><br/>
<code>#include &lt;iterator&gt;</code><br/>
<code>#include &lt;limits&gt;</code><br/>
<code>#include &lt;numeric&gt;</code><br/>
<code>#include &lt;stdexcept&gt;</code><br/>
<code>#include &lt;vector&gt;</code><br/>
</div>
<p><a href="burg_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmean__subtracted.html">mean_subtracted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method-specific estimation variance routines following Broersen.  <a href="structmean__subtracted.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmean__retained.html">mean_retained</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the sample mean was retained in a signal during estimation.  <a href="structmean__retained.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structestimation__method.html">estimation_method</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parent type for autoregressive process parameter estimation techniques.  <a href="structestimation__method.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classYuleWalker.html">YuleWalker&lt; MeanHandling &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents estimation by solving the Yule&ndash;Walker equations.  <a href="classYuleWalker.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBurg.html">Burg&lt; MeanHandling &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents estimation using Burg's recursive method.  <a href="classBurg.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSFB.html">LSFB&lt; MeanHandling &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents forward and backward prediction least squares minimization.  <a href="classLSFB.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLSF.html">LSF&lt; MeanHandling &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents forward prediction least squares minimization.  <a href="classLSF.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structempirical__variance__function.html">empirical_variance_function&lt; EstimationMethod, Result, Integer1, Integer2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL-ready binary_function for a given method's empirical variance.  <a href="structempirical__variance__function.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classempirical__variance__generator.html">empirical_variance_generator&lt; EstimationMethod, Result, Integer1, Integer2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL AdaptableGenerator for a given method's empirical variance.  <a href="classempirical__variance__generator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classempirical__variance__iterator.html">empirical_variance_iterator&lt; EstimationMethod, Result, Integer1, Integer2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable RandomAccessIterator over a method's empirical variance sequence.  <a href="classempirical__variance__iterator.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcriterion.html">criterion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Criteria for autoregressive model order selection following Broersen.  <a href="structcriterion.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGIC.html">GIC&lt; AlphaNumerator, AlphaDenominator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the generalized information criterion (<a class="el" href="structGIC.html" title="Represents the generalized information criterion (GIC).">GIC</a>).  <a href="structGIC.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAIC.html">AIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the Akaike information criterion (<a class="el" href="structAIC.html" title="Represents the Akaike information criterion (AIC).">AIC</a>).  <a href="structAIC.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBIC.html">BIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the consistent criterion <a class="el" href="structBIC.html" title="Represents the consistent criterion BIC.">BIC</a>.  <a href="structBIC.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMCC.html">MCC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the minimally consistent criterion (<a class="el" href="structMCC.html" title="Represents the minimally consistent criterion (MCC).">MCC</a>).  <a href="structMCC.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAICC.html">AICC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the asymptotically-corrected Akaike information criterion (<a class="el" href="structAICC.html" title="Represents the asymptotically-corrected Akaike information criterion (AICC).">AICC</a>).  <a href="structAICC.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFIC.html">FIC&lt; EstimationMethod, AlphaNumerator, AlphaDenominator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the finite information criterion (<a class="el" href="structFIC.html" title="Represents the finite information criterion (FIC) as applied to a particular estimation_method.">FIC</a>) as applied to a particular <a class="el" href="structestimation__method.html">estimation_method</a>.  <a href="structFIC.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFIC_3_01YuleWalker_3_01MeanHandling_01_4_00_01AlphaNumerator_00_01AlphaDenominator_01_4.html">FIC&lt; YuleWalker&lt; MeanHandling &gt;, AlphaNumerator, AlphaDenominator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the finite information criterion (<a class="el" href="structFIC.html" title="Represents the finite information criterion (FIC) as applied to a particular estimation_method.">FIC</a>) as applied to the <a class="el" href="classYuleWalker.html">YuleWalker</a> <a class="el" href="structestimation__method.html">estimation_method</a>.  <a href="structFIC_3_01YuleWalker_3_01MeanHandling_01_4_00_01AlphaNumerator_00_01AlphaDenominator_01_4.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFSIC.html">FSIC&lt; EstimationMethod &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the finite sample information criterion (<a class="el" href="structFSIC.html" title="Represents the finite sample information criterion (FSIC) as applied to a particular estimation_metho...">FSIC</a>) as applied to a particular <a class="el" href="structestimation__method.html">estimation_method</a>.  <a href="structFSIC.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>FSIC&lt; EstimationMethod &gt;::product_iterator&lt; Result, Integer1, Integer2 &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper to compute \(\frac{1+v}{1-v}\) for the method in use. <br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCIC.html">CIC&lt; EstimationMethod &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the combined information criterion (<a class="el" href="structCIC.html" title="Represents the combined information criterion (CIC) as applied to a particular estimation_method.">CIC</a>) as applied to a particular <a class="el" href="structestimation__method.html">estimation_method</a>.  <a href="structCIC.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af6d53897cebd99ddafc014ab0c90cea1"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class Value , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 , class OutputIterator4 &gt; </td></tr>
<tr class="memitem:af6d53897cebd99ddafc014ab0c90cea1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="burg_8hpp.html#af6d53897cebd99ddafc014ab0c90cea1">burg_method</a> (InputIterator data_first, InputIterator data_last, Value &amp;mean, std::size_t &amp;maxorder, OutputIterator1 params_first, OutputIterator2 sigma2e_first, OutputIterator3 gain_first, OutputIterator4 autocor_first, const bool subtract_mean=false, const bool hierarchy=false)</td></tr>
<tr class="memdesc:af6d53897cebd99ddafc014ab0c90cea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithms for autoregressive parameter estimation and manipulation.  <a href="#af6d53897cebd99ddafc014ab0c90cea1"></a><br/></td></tr>
<tr class="memitem:ac9a335bdd9d371c9a75e6b3d33c9eb42"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator , class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ac9a335bdd9d371c9a75e6b3d33c9eb42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="burg_8hpp.html#ac9a335bdd9d371c9a75e6b3d33c9eb42">zohar_linear_solve</a> (RandomAccessIterator a_first, RandomAccessIterator a_last, RandomAccessIterator r_first, InputIterator d_first, OutputIterator s_first)</td></tr>
<tr class="memdesc:ac9a335bdd9d371c9a75e6b3d33c9eb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a Toeplitz set of linear equations.  <a href="#ac9a335bdd9d371c9a75e6b3d33c9eb42"></a><br/></td></tr>
<tr class="memitem:a8fc3882a68369fb8d9968c992dac38e0"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator , class ForwardIterator &gt; </td></tr>
<tr class="memitem:a8fc3882a68369fb8d9968c992dac38e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="burg_8hpp.html#a8fc3882a68369fb8d9968c992dac38e0">zohar_linear_solve</a> (RandomAccessIterator a_first, RandomAccessIterator a_last, RandomAccessIterator r_first, ForwardIterator d_first)</td></tr>
<tr class="memdesc:a8fc3882a68369fb8d9968c992dac38e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a Toeplitz set of linear equations in-place.  <a href="#a8fc3882a68369fb8d9968c992dac38e0"></a><br/></td></tr>
<tr class="memitem:a23f437d7d8d7f1c421fd3049601cce3a"><td class="memTemplParams" colspan="2">template&lt;class RandomAccessIterator , class ForwardIterator &gt; </td></tr>
<tr class="memitem:a23f437d7d8d7f1c421fd3049601cce3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="burg_8hpp.html#a23f437d7d8d7f1c421fd3049601cce3a">zohar_linear_solve</a> (RandomAccessIterator a_first, RandomAccessIterator a_last, ForwardIterator d_first)</td></tr>
<tr class="memdesc:a23f437d7d8d7f1c421fd3049601cce3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a real-valued, symmetric Toeplitz set of linear equations in-place.  <a href="#a23f437d7d8d7f1c421fd3049601cce3a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8351bc749a53488c81a6c89af142cadc"><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Result , typename Integer1 , typename Integer2 &gt; </td></tr>
<tr class="memitem:a8351bc749a53488c81a6c89af142cadc"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="burg_8hpp.html#a8351bc749a53488c81a6c89af142cadc">evaluate</a> (Result sigma2e, Integer1 N, Integer2 p)</td></tr>
<tr class="memdesc:a8351bc749a53488c81a6c89af142cadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a given <a class="el" href="structcriterion.html">criterion</a> for <code>N</code> samples and model order <code>p</code>.  <a href="#a8351bc749a53488c81a6c89af142cadc"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4bb204630ff13c914e681cc6a742079b"><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a4bb204630ff13c914e681cc6a742079b"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="burg_8hpp.html#a4bb204630ff13c914e681cc6a742079b">evaluate_models</a> (Integer1 N, Integer2 ordfirst, InputIterator first, InputIterator last, OutputIterator crit)</td></tr>
<tr class="memdesc:a4bb204630ff13c914e681cc6a742079b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algorithmic helpers for autoregressive model order selection.  <a href="#a4bb204630ff13c914e681cc6a742079b"></a><br/></td></tr>
<tr class="memitem:a2a796834243663cce8b980fbba769329"><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Integer , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 , class OutputIterator &gt; </td></tr>
<tr class="memitem:a2a796834243663cce8b980fbba769329"><td class="memTemplItemLeft" align="right" valign="top">Sequence1::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="burg_8hpp.html#a2a796834243663cce8b980fbba769329">best_model</a> (Integer N, Sequence1 &amp;params, Sequence2 &amp;sigma2e, Sequence3 &amp;gain, Sequence4 &amp;autocor, OutputIterator crit)</td></tr>
<tr class="memdesc:a2a796834243663cce8b980fbba769329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the best model according to <a class="el" href="structcriterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates.  <a href="#a2a796834243663cce8b980fbba769329"></a><br/></td></tr>
<tr class="memitem:a0b03cf499da175467386684a090f1043"><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator &gt; </td></tr>
<tr class="memitem:a0b03cf499da175467386684a090f1043"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="burg_8hpp.html#a0b03cf499da175467386684a090f1043">evaluate_models</a> (Integer1 N, Integer2 ordfirst, InputIterator first, InputIterator last)</td></tr>
<tr class="memdesc:a0b03cf499da175467386684a090f1043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the index of the best model from a hierarchy of candidates according to a <a class="el" href="structcriterion.html">criterion</a> given \(\sigma^2_\epsilon\) for each model.  <a href="#a0b03cf499da175467386684a090f1043"></a><br/></td></tr>
<tr class="memitem:ae2563c52eba50e7ac77d2b6bb2e40815"><td class="memTemplParams" colspan="2">template&lt;class Criterion , typename Integer , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 &gt; </td></tr>
<tr class="memitem:ae2563c52eba50e7ac77d2b6bb2e40815"><td class="memTemplItemLeft" align="right" valign="top">Sequence1::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="burg_8hpp.html#ae2563c52eba50e7ac77d2b6bb2e40815">best_model</a> (Integer N, Sequence1 &amp;params, Sequence2 &amp;sigma2e, Sequence3 &amp;gain, Sequence4 &amp;autocor)</td></tr>
<tr class="memdesc:ae2563c52eba50e7ac77d2b6bb2e40815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the best model according to <a class="el" href="structcriterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates.  <a href="#ae2563c52eba50e7ac77d2b6bb2e40815"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Burg's method and autoregressive model selection. </p>
<p>The selection criteria routines might be sped up for floating point arguments given an appropriate digamma (psi) or Pochhammer symbol implementation. To do so with the GNU Scientific Library, e.g., try </p>
<div class="fragment"><div class="line"><span class="preprocessor">     #include &lt;gsl/gsl_sf_psi.h&gt;</span></div>
<div class="line"><span class="preprocessor">     #define BURG_DIGAMMA(x) gsl_sf_psi(x)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">     #include &lt;gsl/gsl_sf_gamma.h&gt;</span></div>
<div class="line"><span class="preprocessor">     #define BURG_POCHHAMMER(a,x) gsl_sf_poch(a,x)</span></div>
</div><!-- fragment --><p> before including this header and link the GSL with your binary. </p>

<p>Definition in file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2a796834243663cce8b980fbba769329"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Sequence1::difference_type best_model </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence1 &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence2 &amp;&#160;</td>
          <td class="paramname"><em>sigma2e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence3 &amp;&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence4 &amp;&#160;</td>
          <td class="paramname"><em>autocor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>crit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the best model according to <a class="el" href="structcriterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates. </p>
<p>On input, <code>params</code>, <code>sigma2e</code>, <code>gain</code>, and <code>autocor</code> should be <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>s which were populated by <a class="el" href="burg_8hpp.html#af6d53897cebd99ddafc014ab0c90cea1">burg_method</a> when <code>hierarchy</code> is <code>true</code> (or in some other equivalent manner). On output, these arguments will contain only values relevant to the best model.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). For example, the return value of <a class="el" href="burg_8hpp.html#af6d53897cebd99ddafc014ab0c90cea1">burg_method</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params</td><td>Model parameters </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sigma2e</td><td>\(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gain</td><td>Model gain </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">autocor</td><td>Model autocorrelations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crit</td><td>Value assigned to each model by the criterion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The index of the best criterion value within <code>crit</code>. </dd></dl>

<p>Definition at line <a class="el" href="burg_8hpp_source.html#l01367">1367</a> of file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2563c52eba50e7ac77d2b6bb2e40815"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Sequence1::difference_type best_model </td>
          <td>(</td>
          <td class="paramtype">Integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence1 &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence2 &amp;&#160;</td>
          <td class="paramname"><em>sigma2e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence3 &amp;&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence4 &amp;&#160;</td>
          <td class="paramname"><em>autocor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the best model according to <a class="el" href="structcriterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates. </p>
<p>On input, <code>params</code>, <code>sigma2e</code>, <code>gain</code>, and <code>autocor</code> should be <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>s which were populated by <a class="el" href="burg_8hpp.html#af6d53897cebd99ddafc014ab0c90cea1">burg_method</a> when <code>hierarchy</code> is <code>true</code> (or in some other equivalent manner). On output, these arguments will contain only values relevant to the best model.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). For example, the return value of <a class="el" href="burg_8hpp.html#af6d53897cebd99ddafc014ab0c90cea1">burg_method</a>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params</td><td>Model parameters </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sigma2e</td><td>\(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gain</td><td>Model gain </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">autocor</td><td>Model autocorrelations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The index of the best model within the inputs.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>best_model(Integer,Sequence1,Sequence2,Sequence3,Sequence4,OutputIterator) </dd></dl>

<p>Definition at line <a class="el" href="burg_8hpp_source.html#l01502">1502</a> of file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6d53897cebd99ddafc014ab0c90cea1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Value , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 , class OutputIterator4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t burg_method </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>maxorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>params_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>sigma2e_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator3&#160;</td>
          <td class="paramname"><em>gain_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator4&#160;</td>
          <td class="paramname"><em>autocor_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>subtract_mean</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hierarchy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Algorithms for autoregressive parameter estimation and manipulation. </p>
<p>Fit an autoregressive model to stationary time series data using Burg's method. That is, assuming a zero-mean model </p>
<p class="formulaDsp">
\begin{align} x_n + a_1 x_{n - 1} + \dots + a_p x_{n - p} &amp;= \epsilon_n &amp; \epsilon_n &amp;\sim{} N\left(0, \sigma^2_\epsilon\right) \\ \rho_k + a_1 \rho_{k-1} + \dots + a_p \rho_{k-p} &amp;= 0 &amp; k &amp;\geq{} p \end{align}
</p>
<p> find coefficients \(a_i\) such that the sum of the squared errors in the forward predictions \(x_n = -a_1 x_{n-1} - \dots - a_p x_{n-p}\) and backward predictions \(x_n = -a_1 x_{n+1} - \dots - a_p x_{n+p}\) are both minimized. Either a single model of given order or a hierarchy of models up to and including a maximum order may fit.</p>
<p>The input data \(\vec{x}\) are read from <code>[data_first,data_last)</code> in a single pass. The mean is computed using pairwise summation, returned in <code>mean</code>, and <em>removed</em> from further consideration whenever <code>subtract_mean</code> is true. The estimated model parameters \(a_i\) are output using <code>params_first</code> with the behavior determined by the amount of data read, <code>maxorder</code>, and the <code>hierarchy</code> flag: </p>
<ul>
<li>
If <code>hierarchy</code> is <code>false</code>, only the \(a_1, \dots, a_\text{maxorder}\) parameters for an AR(<code>maxorder</code>) process are output. </li>
<li>
If <code>hierarchy</code> is <code>true</code>, the <code>maxorder*(maxorder+1)/2</code> parameters \(a_1, \dots, a_m\) for models AR(0), AR(1), AR(2), ..., AR(maxorder) are output. Notice AR(0) has no parameters.  </li>
</ul>
<p>Note that the latter case is <em>always</em> computed; The <code>hierarchy</code> flag merely controls what is output. In both cases, the maximum order is limited by the number of data samples provided and is output to <code>maxorder</code>.</p>
<p>One mean squared discrepancy \(\sigma^2_\epsilon\), also called the innovation variance, and gain \(\sigma^2_x / \sigma^2_\epsilon\) are output for each model, including the trivial zeroth order model when <code>maxorder</code> is zero or <code>hierarchy</code> is <code>true</code>, using <code>sigma2e_first</code> and <code>gain_first</code>. The autocorrelations for lags <code>[0,k]</code> are output using <code>autocor_first</code>. When <code>hierarchy</code> is <code>true</code>, only lags <code>[0,m]</code> should be applied for some AR(<code>m</code>) model. Outputting the lag <code>k</code> autocorrelation is technically redundant as it may be computed from \(a_i\) and lags <code>0, ..., k-1</code>. Autocovariances may be computed by multiplying the autocorrelations by \(\text{gain} \sigma^2_\epsilon\).</p>
<p>The implementation has been refactored heavily from Cedrick Collomb's 2009 article <a href="http://www.emptyloop.com/technotes/A%20tutorial%20on%20Burg&apos;s%20method,%20algorithm%20and%20recursion.pdf">"Burgâ€™s
 Method, Algorithm and Recursion"</a>. In particular, iterators are employed, the working precision is selectable using <code>mean</code>, the mean squared discrepancy calculation has been added, some loop index transformations have been performed, and all lower order models may be output during the recursion using <code>hierarchy</code>. Gain and autocorrelation calculations have been added based on sections 5.2 and 5.3 of Broersen, P. M. T. Automatic autocorrelation and spectral analysis. Springer, 2006. <a href="http://dx.doi.org/10.1007/1-84628-329-9">http://dx.doi.org/10.1007/1-84628-329-9</a>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of data computed using pairwise summation. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">maxorder</td><td>On input, the maximum model order desired. On output, the maximum model order computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">params_first</td><td>Model parameters for a single model or for an entire hierarchy of models. At most <code>!hierarchy ? maxorder : maxorder*(maxorder+1)/2</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sigma2e_first</td><td>The mean squared discrepancy for only AR(<code>maxorder</code>) or for an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gain_first</td><td>The model gain for only AR(<code>maxorder</code>) or an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">autocor_first</td><td>Lag one through lag maxorder autocorrelations. At most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subtract_mean</td><td>Should <code>mean</code> be subtracted from the data? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hierarchy</td><td>Should the entire hierarchy of estimated models be output?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the number data values processed within [data_first, data_last). </dd></dl>

<p>Definition at line <a class="el" href="burg_8hpp_source.html#l00144">144</a> of file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8351bc749a53488c81a6c89af142cadc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Result , typename Integer1 , typename Integer2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result evaluate </td>
          <td>(</td>
          <td class="paramtype">Result&#160;</td>
          <td class="paramname"><em>sigma2e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a given <a class="el" href="structcriterion.html">criterion</a> for <code>N</code> samples and model order <code>p</code>. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sigma2e</td><td>The residual \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The model order use to compute \(sigma^2_\epsilon\)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>the evaluated criterion. </dd></dl>

<p>Definition at line <a class="el" href="burg_8hpp_source.html#l00915">915</a> of file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4bb204630ff13c914e681cc6a742079b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;InputIterator&gt;::difference_type evaluate_models </td>
          <td>(</td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>ordfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>crit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Algorithmic helpers for autoregressive model order selection. </p>
<p>Evaluate a <a class="el" href="structcriterion.html">criterion</a> on a hierarchy of models given \(\sigma^2_\epsilon\) for each model. The index of the best model, i.e. the one with minimum criterion value, is returned.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ordfirst</td><td>The model order corresponding to <code>first</code>. When \(sigma^2_epsilon\) is produced entirely by <a class="el" href="burg_8hpp.html#af6d53897cebd99ddafc014ab0c90cea1">burg_method</a>, this should be <code>0u</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the range holding \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of input range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crit</td><td>Value assigned to each model by the criterion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The distance from <code>first</code> to the best model. </dd></dl>

<p>Definition at line <a class="el" href="burg_8hpp_source.html#l01302">1302</a> of file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b03cf499da175467386684a090f1043"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;InputIterator&gt;::difference_type evaluate_models </td>
          <td>(</td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>ordfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of the best model from a hierarchy of candidates according to a <a class="el" href="structcriterion.html">criterion</a> given \(\sigma^2_\epsilon\) for each model. </p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ordfirst</td><td>The model order corresponding to <code>first</code>. When \(sigma^2_epsilon\) is produced entirely by <a class="el" href="burg_8hpp.html#af6d53897cebd99ddafc014ab0c90cea1">burg_method</a>, this should be <code>0u</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the range holding \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of input range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The distance from <code>first</code> to the best model.</dd></dl>
<dl class="section see"><dt>See also:</dt><dd>evaluate_models(Criterion,Integer1,Integer2,InputIterator,OutputIterator) </dd></dl>

<p>Definition at line <a class="el" href="burg_8hpp_source.html#l01466">1466</a> of file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac9a335bdd9d371c9a75e6b3d33c9eb42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void zohar_linear_solve </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>r_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>s_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a Toeplitz set of linear equations. </p>
<p>That is, find \(s_{n+1}\) satisfying </p>
<p class="formulaDsp">
\[ L_{n+1} s_{n+1} = d_{n+1} \mbox{ where } L_{n+1} = \bigl(\begin{smallmatrix} 1 &amp; \tilde{a}_n \\ r_n &amp; L_n \end{smallmatrix}\bigr) \]
</p>
<p> given \(\vec{a}\), \(\vec{r}\), and \(\vec{d}\). The dimension of the problem is fixed by <code>n = distance(a_first, a_last)</code>. A symmetric Toeplitz solve can be performed by having \(\vec{a}\) and \(\vec{r}\) iterate over the same data. The Hermitian case requires two buffers with \(vec{r}\) being the conjugate of \(\vec{a}\). The working precision is fixed by the <code>value_type</code> of <code>d_first</code>.</p>
<p>The algorithm is from Zohar, Shalhav. "The Solution of a Toeplitz Set of
 Linear Equations." J. ACM 21 (April 1974): 272-276. <a href="http://dx.doi.org/10.1145/321812.321822">http://dx.doi.org/10.1145/321812.321822</a>. It has complexity like <code>O(2*(n+1)^2)</code>. Zohar improved upon earlier work from Page 1504 from Trench, William F. "Weighting Coefficients for the Prediction of Stationary
 Time Series from the Finite Past." SIAM Journal on Applied Mathematics 15 (November 1967): 1502-1510. <a href="http://www.jstor.org/stable/2099503">http://www.jstor.org/stable/2099503</a>. See Bunch, James R. "Stability of Methods for Solving Toeplitz Systems of
 Equations." SIAM Journal on Scientific and Statistical Computing 6 (1985): 349-364. <a href="http://dx.doi.org/10.1137/0906025">http://dx.doi.org/10.1137/0906025</a> for a discussion of the algorithms stability characteristics.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>End of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_first</td><td>Beginning of the range containing \(\vec{r}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_first</td><td>Beginning of the range containing \(\vec{d}\) which should have <code>n+1</code> entries available. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s_first</td><td>Beginning of the output range to which <code>n+1</code> entries will be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="burg_8hpp_source.html#l00317">317</a> of file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fc3882a68369fb8d9968c992dac38e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void zohar_linear_solve </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>r_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>d_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a Toeplitz set of linear equations in-place. </p>
<p>That is, compute </p>
<p class="formulaDsp">
\[ L_{n+1}^{-1} d_{n+1} \mbox{ for } L_{n+1} = \bigl(\begin{smallmatrix} 1 &amp; \tilde{a}_n \\ r_n &amp; L_n \end{smallmatrix}\bigr) \]
</p>
<p> given \(\vec{a}\), \(\vec{r}\), and \(\vec{d}\). The dimension of the problem is fixed by <code>n = distance(a_first, a_last)</code>. A symmetric Toeplitz solve can be performed by having \(\vec{a}\) and \(vec{r}\) iterate over the same data. The Hermitian case requires two buffers with \(vec{r}\) being the conjugate of \(\vec{a}\). The working precision is fixed by the <code>value_type</code> of <code>d_first</code>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>End of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_first</td><td>Beginning of the range containing \(\vec{r}\). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_first</td><td>Beginning of the range containing \(\vec{d}\). Also the beginning of the output range to which <b><code>n+1</code></b> entries will be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="burg_8hpp_source.html#l00462">462</a> of file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>

<p>References <a class="el" href="burg_8hpp_source.html#l00317">zohar_linear_solve()</a>.</p>

</div>
</div>
<a class="anchor" id="a23f437d7d8d7f1c421fd3049601cce3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void zohar_linear_solve </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>d_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a real-valued, symmetric Toeplitz set of linear equations in-place. </p>
<p>That is, compute </p>
<p class="formulaDsp">
\[ L_{n+1}^{-1} d_{n+1} \mbox{ for } L_{n+1} = \bigl(\begin{smallmatrix} 1 &amp; \tilde{a}_n \\ a_n &amp; L_n \end{smallmatrix}\bigr) \]
</p>
<p> given \(\vec{a}\) and \(\vec{d}\). The dimension of the problem is fixed by <code>n = distance(a_first, a_last)</code>. The working precision is fixed by the <code>value_type</code> of <code>d_first</code>.</p>
<dl class="params"><dt>Parameters:</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>End of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_first</td><td>Beginning of the range containing \(\vec{d}\). Also the beginning of the output range to which <b><code>n+1</code></b> entries will be written. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="burg_8hpp_source.html#l00495">495</a> of file <a class="el" href="burg_8hpp_source.html">burg.hpp</a>.</p>

<p>References <a class="el" href="burg_8hpp_source.html#l00317">zohar_linear_solve()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 28 2012 14:03:57 for Burg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>
